> ## 5、如何保证消息的顺序性？ 

其实这问题就是可以拆解为两个角度分析。① 你了解顺序这个事儿吗？② 你有没有办法保证消息是有顺序的？

老规矩，我们还是先来看看 RabbitMQ 和 Kafka 顺序会错乱的俩场景：

- #### **RabbitMQ**

  - 场景

    一个 Queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条消息，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别中 MQ 中消费者三条数据中的一条，结果 消费者2 先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱套了吗？如图：

    ![image-20220907223835220](06-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F.assets/image-20220907223835220.png)
    
  - **解决方案**
  
  拆分成多个 `Queue`，每个 Queue 一个 Consumer，就是多一些 Queue 而已，确实是麻烦点儿，这样也会造成吞吐量的下降，可以在消费者内部采用多线程的方式去消费。
  
  或者就是一个 Queue 对应一个 consumer，然后这个 consumer 内部`用内存队列做排序`，然后分发给底层不同的 `worker` 来处理。
  
  > 【注意】这里消费者不直接消费消息，而是将消息根据关键值（比如：订单 id）进行哈希，哈希值相同的消息保存到相同的内存队列里。也就是说，需要保证顺序的消息存到了相同的内存队列中，而后由一个唯一的 `worker` 去处理。
  

![image-20220907223905425](06-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F.assets/image-20220907223905425.png)

- #### **Kafka**

  - 场景

    假如我们创建了一个 `topic`，它有三个 `partition`。生产者在写的时候，其实可以指定一个 `key`，比如我们指定了某个订单的 id 作为 key，那么这个订单相关的数据一定会被分配到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。

    消费者从 partition 中去数据时，也一定是有顺序的。到这里，顺序其实都还是OK的，没有错乱。接下来，我们在消费者留可能会搞个多线程来并发处理消息。因为如果消费者是单线程消费处理，而且处理一条消息数据比较耗时的话，比如处理一条消息耗时几十 ms，那么 1s 中也只能处理几十条消息，这效率，这吞吐量也忒低了点儿。儿多线程并发跑的话，顺序可能就乱掉了。

    ![image-20220907223957129](06-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F.assets/image-20220907223957129.png)

  - 解决方案

    - 一个 `topic`，一个 `partition`，一个 `consumer`，内存单线程消费，但是单线程吞吐量太低，一般不会用这种方式。
    - 写 N 个内存 `Queue`，具有相同 `key` 的数据都到同一个内存 `Queue`；对于 N 个线程，每个线程分别消费一个内存 `Queue` 即可，这样就能保证消息消费的顺序性。

    ![image-20220907224032084](06-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F.assets/image-20220907224032084.png)