<书接上回>

消费者从 partition 中去数据时，也一定是有顺序的。到这里，顺序其实都还是OK的，没有错乱。接下来，我们在消费者留可能会搞个多线程来并发处理消息。因为如果消费者是单线程消费处理，而且处理一条消息数据比较耗时的话，比如处理一条消息耗时几十 ms，那么 1s 中也只能处理几十条消息，这效率，这吞吐量也忒低了点儿。儿多线程并发跑的话，顺序可能就乱掉了。

    ![1662535746519](D:\OpenCode\1662535746519.png)

  - 解决方案

    - 一个 `topic`，一个 `partition`，一个 `consumer`，内存单线程消费，但是单线程吞吐量太低，一般不会用这种方式。
    - 写 N 个内存 `Queue`，具有相同 `key` 的数据都到同一个内存 `Queue`；对于 N 个线程，每个线程分别消费一个内存 `Queue` 即可，这样就能保证消息消费的顺序性。

    ![1662536757984](D:\OpenCode\1662536757984.png)
