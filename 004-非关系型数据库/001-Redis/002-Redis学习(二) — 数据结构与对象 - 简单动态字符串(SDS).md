# Redis学习(二) — 数据结构与对象 - 简单动态字符串(SDS)

## 简单动态字符串（Simple Dynamic String - SDS）

### 1. Redis 数据库键值对

#### Redis数据库里面的每个键值对（key-value pair）都是由对象（Object）组成的，其中：

- **数据库键总是一个字符串对象**（String Object）；
- 而数据库键的值则可以是以下五种中的一种：
  - **字符串对象（String Object）**
  - **列表对象（list Object）**
  - **哈希对象（hash Object）**
  - **集合对象（set Object）**
  - **有序对象（sorted set Object）**

比如，执行以下命令将在数据库中创建一个键为字符串对象，值也为字符串对象的键值对：

```sql
redis> SET msg "hello redis"
OK
```

获取这个字符串对象：

```sql
redis>GET mdg
"hello redis"
```

而执行以下命令将在数据库中创建一个键为字符串对象，值为列表对象的键值对：

```sql
redis>RPUSH num 1 3 5 7 9
(integer) 5
```

获取这个列表对象的值：

```sql
redis>LRANGE num 0 4
1) "1"
2) "3"
3) "5"
4) "7"
5) "9"
```

#### [注] 命令

- ### Redis Rpush 命令

  Redis Rpush 命令用于将一个或多个值插入到列表的尾部(最右边)。

  如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误。

- ### 返回值

  执行 RPUSH 操作后，列表的长度。

  例如：

  ```sql
  redis>RPUSH num 1 3 5 7 9
  (integer) 5
  ```

- ### 获取值

  执行LRANGE操作，获取从 start 到 end 的值

  例如：

  ```sql
  redis>LRANGE num 0 4
  1) "1"
  2) "3"
  3) "5"
  4) "7"
  5) "9"
  ```

### 2. SDS(简单动态字符串)的定义

#### 2.1 SDS：Simple Dynamic String ，简单动态字符串。SDS用作Redis的默认字符串表示。

每个sds.h/sdahdr结构表示一个SDS值：

```java
struct sdahdr {
    // 记录buf数组中以使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    
    // 记录buf数组中未使用字节的数量
    int free;
    
    // 字节数组，用于保存字符串
    char buf;
}
```

![1634630487588](D:\WorkSpace\ywbGithubOpenCode\mwiki-main\mNote\library\004-Redis\sdshdr定义图.png)

如图所示：

- free 属性的值为0，表示这个SDS没有分配任何未使用空间。
- len 属性的值为5，表示这个SDS保存了一个5字节长的字符串。
- buf 属性是一个char类型的数组，数组的前5个字节分别保存了 ‘R’、‘e’、‘d’、‘i’、‘s’ 五个字符，而最后一个字节则保存了‘\0’。

**SDS遵循C字符串以空字符串结尾的管理，保存空字符串的1字节空间不计算在SDS的len属性里面，并且为空字符串额外分配的1字节空间，以及添加空字符串到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说是完全透明的。遵循空字符串结尾这一管理的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。**

#### 2.2 SDS与C字符串的区别

- ##### 常数复杂度获取字符串长度

  - 因为C字符串并不记录自身长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止。这个操作的复杂度为*O(n)*。与C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为*O(1)*。

- ##### 杜绝缓冲区溢出

  - 除了获取字符串长的复杂度之外，C字符串不记录自身长度带来的另外一个问题是容易造成缓冲区溢出（buffer overflow）。举个例子，`<string.h>/strcat`函数可以将src字符串中的内容拼接到dest字符串的末尾。

    ```c
    char *strcat(char *dest, const char *src);
    ```

    因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时，已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲去溢出。与C字符串不同，SDS的空见分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足多的话，API会自动将SDS的空间扩展至执行修改的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

- ##### 减少修改字符串时带来的内存重新分配次数

  - C字符串在每一次扩展字符串的长度的时，都需要重新在内存中分配空间。在一般程序中，如果修改字符串长度的情况不太长出现，那么每次修改都需要执行一次内存重新分配是可以接受的。

  - 但Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存分配的话，那么光是执行内存重新分配的时间就会占去修改字符串所用时间的一大部分，如果这种频繁发生的话，会对数据库的性能造影响。

  - 为了避免C字符串的以上这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：`在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。`

    - ##### 通过未使用空间，SDS实现了`空间预分配`和`惰性空间释放`两种优化策略。

      - ###### 空间与分配

        空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。

      - ###### 惰性空间释放

        惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

#### 2.3 二进制安全

	为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放的buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据写入时是什么样，它被读取时就是什么样。

#### 2.4 兼容部分C字符串

	虽然SDS的API都是二进制安全的，但它们一样遵循C字符串以空字符串结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个字符串，这是为了让那些保存文本数据的SDS可以重用一部分`<string.h>`库定义的函数，从而避免了不必要的代码重复。
